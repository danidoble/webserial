"use strict";var de=Object.defineProperty;var Q=l=>{throw TypeError(l)};var fe=(l,e,t)=>e in l?de(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t;var R=(l,e,t)=>fe(l,typeof e!="symbol"?e+"":e,t),$=(l,e,t)=>e.has(l)||Q("Cannot "+t);var v=(l,e,t)=>($(l,e,"read from private field"),t?t.call(l):e.get(l)),I=(l,e,t)=>e.has(l)?Q("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(l):e.set(l,t),N=(l,e,t,n)=>($(l,e,"write to private field"),n?n.call(l,t):e.set(l,t),t),a=(l,e,t)=>($(l,e,"access private method"),t);function ee(l=100){return new Promise(e=>setTimeout(()=>e(),l))}function pe(){return"serial"in navigator}function ge(){return"geolocation"in navigator}function me(){return"crypto"in window}function ye(l=1){return l*1e3}function be(l){return l==null||l===""}var S,x,s,te,ne,c,j,m,p,L,o,O,M;const i=class i{static status(e=null){var n,r;if(!a(n=i,s,c).call(n,e))return!1;let t=[];switch(v(i,S)){case"locker":t=["0","8"];break;case"boardroid":t=["2",(5+v(i,x)).toString(16).toUpperCase()];break;case"jofemar":t=["6"];break;default:return!1}a(r=i,s,o).call(r,t)}static dispensed(e=null){var n,r;if(!a(n=i,s,c).call(n,e))return!1;let t=[];switch(v(i,S)){case"locker":t=["0","7","4","4","4"];break;case"boardroid":t=["2","D7","A","0","0","0","0","0","0","0","0","0","F2"];break;case"jofemar":t=["6","30"];break;default:return!1}a(r=i,s,o).call(r,t)}static notDispensed(e=null){var n,r;if(!a(n=i,s,c).call(n,e))return!1;let t=[];switch(v(i,S)){case"locker":t=["0","7","5","5","5"];break;case"boardroid":t=["2","D7","A","0","0","1","0","0","0","0","0","0","F2"];break;case"jofemar":t=["6","34"];break;default:return!1}a(r=i,s,o).call(r,t)}static gateInactive(e=null){var t;if(!a(t=i,s,c).call(t,e)||!a(this,s,j).call(this))return!1;a(this,s,o).call(this,["0","7","5","5","5"])}static gateConfigured(e=null){var t;if(!a(t=i,s,c).call(t,e)||!a(this,s,j).call(this))return!1;a(this,s,o).call(this,["0","6"])}static keyPressed(e=null){var _,f,h;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,p).call(f))return!1;const t=["30","31","32","33","34","35","36","37","38","39","2A","23","41","42","43","44"],n=(128+v(i,x)).toString(16),r=Math.floor(Math.random()*15);a(h=i,s,o).call(h,["2",n,"54",t[r]])}static doorOpened(e=null){var r,_;if(!a(r=i,s,c).call(r,e)||!a(this,s,L).call(this))return!1;let t=[];const n=(128+v(i,x)).toString(16);switch(v(i,S)){case"boardroid":t=["2","D8","dc"];break;case"jofemar":t=["2",n,"50","4F"];break}a(_=i,s,o).call(_,t)}static doorClosed(e=null){var r,_;if(!a(r=i,s,c).call(r,e)||!a(this,s,L).call(this))return!1;let t=[];const n=(128+v(i,x)).toString(16);switch(v(i,S)){case"boardroid":t=["2","D8","db"];break;case"jofemar":t=["2",n,"50","43"];break}a(_=i,s,o).call(_,t)}static channelDisconnected(e=null){var n,r,_;if(!a(n=i,s,c).call(n,e)||!a(r=i,s,p).call(r))return!1;const t=(128+v(i,x)).toString(16);a(_=i,s,o).call(_,["2",t,"43","43","43","FD"])}static channelConnected(e=null){var n,r,_;if(!a(n=i,s,c).call(n,e)||!a(r=i,s,p).call(r))return!1;const t=(128+v(i,x)).toString(16);a(_=i,s,o).call(_,["2",t,"43","43","43","FC"])}static channelEmpty(e=null){var n,r,_;if(!a(n=i,s,c).call(n,e)||!a(r=i,s,p).call(r))return!1;const t=(128+v(i,x)).toString(16);a(_=i,s,o).call(_,["2",t,"43","43","43","FF"])}static workingTemperature(e=null){var n,r,_;if(!a(n=i,s,c).call(n,e)||!a(r=i,s,p).call(r))return!1;const t=(128+v(i,x)).toString(16);a(_=i,s,o).call(_,["2",t,"43","54","16"])}static currentTemperature(e=null){var r,_,f;if(!a(r=i,s,c).call(r,e)||!a(_=i,s,L).call(_))return!1;let t=[];const n=(128+v(i,x)).toString(16);switch(v(i,S)){case"boardroid":t=["2","D9","44","30"];break;case"jofemar":t=["2",n,"43","74","2B","30","39","2E","31","7F","43"];break}a(f=i,s,o).call(f,t)}static ready(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","30"])}static busy(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","31"])}static invalidTray(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","32"])}static invalidChannel(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","33"])}static emptyChannel(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","34"])}static elevatorJam(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","35"])}static elevatorMalfunction(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","36"])}static phototransistorFailure(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","37"])}static allChannelsEmpty(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","38"])}static productDetectorFailure(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","39"])}static displayDisconnected(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","41"])}static productUnderElevator(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","42"])}static elevatorSettingAlarm(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","43"])}static buttonPanelFailure(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","44"])}static errorWritingEeprom(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","45"])}static errorControlTemperature(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","46"])}static thermometerDisconnected(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","47"])}static thermometerMisconfigured(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","48"])}static thermometerFailure(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","49"])}static errorExtractorConsumption(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4A"])}static channelSearchError(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4B"])}static productExitMouthSearchError(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4C"])}static elevatorInteriorLocked(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4D"])}static productDetectorVerifierError(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4E"])}static waitingForProductRecall(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4F"])}static productExpiredByTemperature(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","50"])}static faultyAutomaticDoor(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","51"])}static rejectLever(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","A0","1"])}static resetCoinPurse(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","A0","2"])}static coinInsertedBox(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["40","41","42","43","44","45"],r=a(h=i,s,O).call(h,n,t);a(d=i,s,o).call(d,["2","A0",r])}static coinInsertedTube(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["50","51","52","53","54","55"],r=a(h=i,s,O).call(h,n,t);a(d=i,s,o).call(d,["2","A0",r])}static banknoteInsertedStacker(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["80","81","82","83","84"],r=a(h=i,s,M).call(h,n,t);a(d=i,s,o).call(d,["2","B0",r])}static banknoteInsertedEscrow(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["90","91","92","93","94"],r=a(h=i,s,M).call(h,n,t);a(d=i,s,o).call(d,["2","B0",r])}static banknoteEjected(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["A0","A1","A2","A3","A4"],r=a(h=i,s,M).call(h,n,t);a(d=i,s,o).call(d,["2","B0",r])}static banknoteInsertedRecycler(e=null,t=null){var _,f,h,d;if(!a(_=i,s,c).call(_,e)||!a(f=i,s,m).call(f))return!1;const n=["B0","B1","B2","B3","B4"],r=a(h=i,s,M).call(h,n,t);a(d=i,s,o).call(d,["2","B0",r])}static banknoteTaken(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","B0","2a"])}static coinPurseEnabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D0","1"])}static coinPurseDisabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D0","0"])}static billPurseDisabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D1","0","0"])}static billPurseEnabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D1","1","1"])}static readTubes(e=null){var w,C,k;if(!a(w=i,s,c).call(w,e)||!a(C=i,s,m).call(C))return!1;const t=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f"],[n,r,_,f,h,d]=[t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)]];a(k=i,s,o).call(k,["2","D2",n,r,_,f,h,d])}static readBillPurse(e=null,t=null){var r,_,f,h;if(!a(r=i,s,c).call(r,e)||!a(_=i,s,m).call(_))return!1;let n=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c"];if(e._recycler.ict){const d=n[Math.floor(Math.random()*31)];let w="0",C="0",k="0",D="0",A="0";if(t!==null&&!isNaN(parseInt(t)))switch(t.toString()){case"20":w=d;break;case"50":C=d;break;case"100":k=d;break;case"200":D=d;break;case"500":A=d;break}else switch(e._recycler.bill){case 0:w=d;break;case 1:C=d;break;case 2:k=d;break;case 3:D=d;break;case 4:A=d;break}a(f=i,s,o).call(f,["2","D3",w,C,k,D,A,"0"])}else{const[d,w,C,k,D,A]=[n[Math.floor(Math.random()*30)],n[Math.floor(Math.random()*30)],n[Math.floor(Math.random()*30)],n[Math.floor(Math.random()*2)],n[Math.floor(Math.random())],n[Math.floor(Math.random())]];a(h=i,s,o).call(h,["2","D3",d,w,C,k,D,A])}}static banknoteAccepted(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D4","1"])}static banknoteRejected(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D4","0"])}static banknotesDispensed(e=null){var n,r,_,f;if(!a(n=i,s,c).call(n,e)||!a(r=i,s,m).call(r))return!1;let t=["1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c"];if(e._recycler.ict){const h=t[Math.floor(Math.random()*30)];let d="0",w="0",C="0",k="0",D="0";switch(e._recycler.bill){case 0:d=h;break;case 1:w=h;break;case 2:C=h;break;case 3:k=h;break;case 4:D=h;break}a(_=i,s,o).call(_,["2","D5",d,w,C,k,D,"0"])}else{const[h,d,w,C,k,D]=[t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*30)],t[Math.floor(Math.random()*2)],t[Math.floor(Math.random())],t[Math.floor(Math.random())]];a(f=i,s,o).call(f,["2","D5",h,d,w,C,k,D])}}static coinsDispensed(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","D6"])}static relayOn(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DA","1"])}static relayOff(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DA","0"])}static nayaxEnabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","1"])}static nayaxDisabled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","0"])}static nayaxPreCreditAuthorized(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","3"])}static nayaxCancelRequest(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","4"])}static nayaxSellApproved(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","5"])}static nayaxSellDenied(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","6"])}static nayaxEndSession(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","7"])}static nayaxCancelled(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","8"])}static nayaxDispensed(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","A","0"])}static nayaxNotDispensed(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,m).call(n))return!1;a(r=i,s,o).call(r,["2","DD","A","1"])}static fullTray(e=null){var t,n,r;if(!a(t=i,s,c).call(t,e)||!a(n=i,s,p).call(n))return!1;a(r=i,s,o).call(r,["6","4F"])}static setConnection(e=null){var t;if(!a(t=i,s,c).call(t,e))return!1;e.__internal__.serial.connected=!0}};S=new WeakMap,x=new WeakMap,s=new WeakSet,te=function(){if(i.enable===!1)throw new Error("Emulator is disabled");return i.enable},ne=function(e){if(typeof e!="object"||!(e instanceof he))throw new Error(`Type ${e.typeDevice} is not supported`);return i.instance=e,N(i,S,e.typeDevice),N(i,x,e.deviceNumber),!0},c=function(e=null){var t,n;return!a(t=i,s,te).call(t)||e===null&&i.instance===null?!1:(i.instance===null&&a(n=i,s,ne).call(n,e),!0)},j=function(){if(v(i,S)!=="locker")throw new Error("This function is only available for Locker devices");return!0},m=function(){if(v(i,S)!=="boardroid")throw new Error("This function is only available for Boardroid devices");return!0},p=function(){if(v(i,S)!=="jofemar")throw new Error("This function is only available for Jofemar devices");return!0},L=function(){if(v(i,S)==="locker")throw new Error("This function is not available for Locker devices");return!0},o=function(e){i.instance.__emulate({code:e})},O=function(e,t=null){let n=e[Math.floor(Math.random()*5)];if(t!==null&&!isNaN(parseFloat(t)))switch(t.toString()){case"0.5":n=e[1];break;case"1":n=e[2];break;case"2":n=e[3];break;case"5":n=e[4];break;case"10":n=e[5];break}return n},M=function(e,t=null){let n=e[Math.floor(Math.random()*4)];if(t!==null&&!isNaN(parseFloat(t)))switch(t.toString()){case"20":n=e[0];break;case"50":n=e[1];break;case"100":n=e[2];break;case"200":n=e[3];break;case"500":n=e[4];break}return n},I(i,s),R(i,"enable",!1),R(i,"instance",null),I(i,S,null),I(i,x,1);let U=i;var we=Object.defineProperty,ie=l=>{throw TypeError(l)},ve=(l,e,t)=>e in l?we(l,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):l[e]=t,P=(l,e,t)=>ve(l,typeof e!="symbol"?e+"":e,t),Ce=(l,e,t)=>e.has(l)||ie("Cannot "+t),Se=(l,e,t)=>e.has(l)?ie("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(l):e.set(l,t),y=(l,e,t)=>(Ce(l,e,"access private method"),t);class J extends CustomEvent{constructor(e,t){super(e,t)}}class re extends EventTarget{constructor(){super(...arguments),P(this,"__listeners__",{debug:!1}),P(this,"__debug__",!1)}dispatch(e,t=null){const n=new J(e,{detail:t});this.dispatchEvent(n),this.__debug__&&this.dispatchEvent(new J("debug",{detail:{type:e,data:t}}))}dispatchAsync(e,t=null,n=100){const r=this;setTimeout(()=>{r.dispatch(e,t)},n)}on(e,t){typeof this.__listeners__[e]<"u"&&!this.__listeners__[e]&&(this.__listeners__[e]=!0),this.addEventListener(e,t)}off(e,t){this.removeEventListener(e,t)}serialRegisterAvailableListener(e){this.__listeners__[e]||(this.__listeners__[e]=!1)}get availableListeners(){return Object.keys(this.__listeners__).sort().map(e=>({type:e,listening:this.__listeners__[e]}))}}const q=class b extends re{constructor(){super(),["change"].forEach(e=>{this.serialRegisterAvailableListener(e)})}static $dispatchChange(e=null){e&&e.$checkAndDispatchConnection(),b.instance.dispatch("change",{devices:b.devices,dispatcher:e})}static typeError(e){const t=new Error;throw t.message=`Type ${e} is not supported`,t.name="DeviceTypeError",t}static registerType(e){typeof b.devices[e]>"u"&&(b.devices[e]={})}static add(e){const t=e.typeDevice;typeof b.devices[t]>"u"&&(b.devices[t]={});const n=e.uuid;if(typeof b.devices[t]>"u"&&b.typeError(t),b.devices[t][n])throw new Error(`Device with id ${n} already exists`);return b.devices[t][n]=e,b.$dispatchChange(e),Object.keys(b.devices[t]).indexOf(n)}static get(e,t){return typeof b.devices[e]>"u"&&(b.devices[e]={}),typeof b.devices[e]>"u"&&b.typeError(e),b.devices[e][t]}static getAll(e=null){return e===null?b.devices:(typeof b.devices[e]>"u"&&b.typeError(e),b.devices[e])}static getList(){return Object.values(b.devices).map(e=>Object.values(e)).flat()}static getByNumber(e,t){return typeof b.devices[e]>"u"&&b.typeError(e),Object.values(b.devices[e]).find(n=>n.deviceNumber===t)??null}static getCustom(e,t=1){return typeof b.devices[e]>"u"&&b.typeError(e),Object.values(b.devices[e]).find(n=>n.deviceNumber===t)??null}};P(q,"instance"),P(q,"devices",{});let u=q;u.instance||(u.instance=new u);function H(l=100){return new Promise(e=>setTimeout(()=>e(),l))}function ke(){return"serial"in navigator}const F={baudRate:9600,dataBits:8,stopBits:1,parity:"none",bufferSize:32768,flowControl:"none"};var g,T,B,W,V,E,se,G,z,K,X,ae,le,oe,ce,Y,Z,_e,ue;class xe extends re{constructor({filters:e=null,config_port:t=F,no_device:n=1,device_listen_on_channel:r=1,bypassSerialBytesConnection:_=!1}={filters:null,config_port:F,no_device:1,device_listen_on_channel:1,bypassSerialBytesConnection:!1}){if(super(),Se(this,g),P(this,"__internal__",{bypassSerialBytesConnection:!1,auto_response:!1,device_number:1,aux_port_connector:0,last_error:{message:null,action:null,code:null,no_code:0},serial:{connected:!1,port:null,last_action:null,response:{length:null,buffer:new Uint8Array([]),as:"uint8",replacer:/[\n\r]+/g,limiter:null,prefixLimiter:!1,sufixLimiter:!0,delimited:!1},reader:null,input_done:null,output_done:null,input_stream:null,output_stream:null,keep_reading:!0,time_until_send_bytes:void 0,delay_first_connection:200,bytes_connection:null,filters:[],config_port:F,queue:[],auto_response:["DD","DD"],free_timeout_ms:50,useRTSCTS:!1},device:{type:"unknown",id:window.crypto.randomUUID(),listen_on_port:null},time:{response_connection:500,response_general:2e3},timeout:{until_response:0},interval:{reconnection:0}}),!("serial"in navigator))throw new Error("Web Serial not supported");e&&(this.serialFilters=e),t&&(this.serialConfigPort=t),_&&(this.__internal__.bypassSerialBytesConnection=_),n&&y(this,g,_e).call(this,n),r&&["number","string"].includes(typeof r)&&(this.listenOnChannel=r),y(this,g,oe).call(this),y(this,g,ce).call(this)}set listenOnChannel(e){if(typeof e=="string"&&(e=parseInt(e)),isNaN(e)||e<1||e>255)throw new Error("Invalid port number");this.__internal__.device.listen_on_port=e,!this.__internal__.bypassSerialBytesConnection&&(this.__internal__.serial.bytes_connection=this.serialSetConnectionConstant(e))}get lastAction(){return this.__internal__.serial.last_action}get listenOnChannel(){return this.__internal__.device.listen_on_port??1}set serialFilters(e){if(this.isConnected)throw new Error("Cannot change serial filters while connected");this.__internal__.serial.filters=e}get serialFilters(){return this.__internal__.serial.filters}set serialConfigPort(e){if(this.isConnected)throw new Error("Cannot change serial filters while connected");this.__internal__.serial.config_port=e}get serialConfigPort(){return this.__internal__.serial.config_port}get useRTSCTS(){return this.__internal__.serial.useRTSCTS}set useRTSCTS(e){this.__internal__.serial.useRTSCTS=e}get isConnected(){const e=this.__internal__.serial.connected,t=y(this,g,T).call(this,this.__internal__.serial.port);return e&&!t&&y(this,g,B).call(this,{error:"Port is closed, not readable or writable."}),this.__internal__.serial.connected=t,this.__internal__.serial.connected}get isDisconnected(){const e=this.__internal__.serial.connected,t=y(this,g,T).call(this,this.__internal__.serial.port);return!e&&t&&(this.dispatch("serial:connected"),u.$dispatchChange(this)),this.__internal__.serial.connected=t,!this.__internal__.serial.connected}get deviceNumber(){return this.__internal__.device_number}get uuid(){return this.__internal__.device.id}get typeDevice(){return this.__internal__.device.type}get queue(){return this.__internal__.serial.queue}get responseDelimited(){return this.__internal__.serial.response.delimited}set responseDelimited(e){if(typeof e!="boolean")throw new Error("responseDelimited must be a boolean");this.__internal__.serial.response.delimited=e}get responsePrefixLimited(){return this.__internal__.serial.response.prefixLimiter}set responsePrefixLimited(e){if(typeof e!="boolean")throw new Error("responsePrefixLimited must be a boolean");this.__internal__.serial.response.prefixLimiter=e}get responseSufixLimited(){return this.__internal__.serial.response.sufixLimiter}set responseSufixLimited(e){if(typeof e!="boolean")throw new Error("responseSufixLimited must be a boolean");this.__internal__.serial.response.sufixLimiter=e}get responseLimiter(){return this.__internal__.serial.response.limiter}set responseLimiter(e){if(typeof e!="string"&&!(e instanceof RegExp))throw new Error("responseLimiter must be a string or a RegExp");this.__internal__.serial.response.limiter=e}get fixedBytesMessage(){return this.__internal__.serial.response.length}set fixedBytesMessage(e){if(e!==null&&(typeof e!="number"||e<1))throw new Error("Invalid length for fixed bytes message");this.__internal__.serial.response.length=e}get timeoutBeforeResponseBytes(){return this.__internal__.serial.free_timeout_ms||50}set timeoutBeforeResponseBytes(e){if(e!==void 0&&(typeof e!="number"||e<1))throw new Error("Invalid timeout for response bytes");this.__internal__.serial.free_timeout_ms=e??50}get bypassSerialBytesConnection(){return this.__internal__.bypassSerialBytesConnection}set bypassSerialBytesConnection(e){if(typeof e!="boolean")throw new Error("bypassSerialBytesConnection must be a boolean");this.__internal__.bypassSerialBytesConnection=e}async timeout(e,t){this.__internal__.last_error.message="Operation response timed out.",this.__internal__.last_error.action=t,this.__internal__.last_error.code=e,this.__internal__.timeout.until_response&&(clearTimeout(this.__internal__.timeout.until_response),this.__internal__.timeout.until_response=0),t==="connect"?(this.__internal__.serial.connected=!1,this.dispatch("serial:reconnect",{}),u.$dispatchChange(this)):t==="connection:start"&&(await this.serialDisconnect(),this.__internal__.serial.connected=!1,this.__internal__.aux_port_connector+=1,u.$dispatchChange(this),await this.serialConnect()),this.dispatch("serial:timeout",{...this.__internal__.last_error,bytes:e,action:t})}async disconnect(e=null){await this.serialDisconnect(),y(this,g,B).call(this,e)}async connect(){return this.isConnected?`${this.typeDevice} device ${this.deviceNumber} already connected`:new Promise((e,t)=>{ke()||t("Web Serial not supported"),setTimeout(async()=>{await H(499),await this.serialConnect(),this.isConnected?e(`${this.typeDevice} device ${this.deviceNumber} connected`):t(`${this.typeDevice} device ${this.deviceNumber} not connected`)},1)})}async serialDisconnect(){try{const e=this.__internal__.serial.reader,t=this.__internal__.serial.output_stream;e&&(await e.cancel().catch(n=>this.serialErrors(n)),await this.__internal__.serial.input_done),t&&(await t.getWriter().close(),await this.__internal__.serial.output_done),this.__internal__.serial.connected&&this.__internal__.serial&&this.__internal__.serial.port&&await this.__internal__.serial.port.close()}catch(e){this.serialErrors(e)}finally{this.__internal__.serial.reader=null,this.__internal__.serial.input_done=null,this.__internal__.serial.output_stream=null,this.__internal__.serial.output_done=null,this.__internal__.serial.connected=!1,this.__internal__.serial.port=null,u.$dispatchChange(this)}}getResponseAsArrayBuffer(){this.__internal__.serial.response.as="arraybuffer"}getResponseAsArrayHex(){this.__internal__.serial.response.as="hex"}getResponseAsUint8Array(){this.__internal__.serial.response.as="uint8"}getResponseAsString(){this.__internal__.serial.response.as="string"}async serialPortsSaved(e){const t=this.serialFilters;if(this.__internal__.aux_port_connector<e.length){const n=this.__internal__.aux_port_connector;this.__internal__.serial.port=e[n]}else this.__internal__.aux_port_connector=0,this.__internal__.serial.port=await navigator.serial.requestPort({filters:t});if(!this.__internal__.serial.port)throw new Error("Select another port please")}serialErrors(e){const t=e.toString().toLowerCase();switch(!0){case t.includes("must be handling a user gesture to show a permission request"):case t.includes("the port is closed."):case t.includes("the port is closed or is not writable"):case t.includes("the port is closed or is not readable"):case t.includes("the port is closed or is not readable/writable"):case t.includes("select another port please"):case t.includes("no port selected by the user"):case t.includes("this readable stream reader has been released and cannot be used to cancel its previous owner stream"):this.dispatch("serial:need-permission",{}),u.$dispatchChange(this);break;case t.includes("the port is already open."):case t.includes("failed to open serial port"):this.serialDisconnect().then(async()=>{this.__internal__.aux_port_connector+=1,await this.serialConnect()});break;case t.includes("cannot read properties of undefined (reading 'writable')"):case t.includes("cannot read properties of null (reading 'writable')"):case t.includes("cannot read property 'writable' of null"):case t.includes("cannot read property 'writable' of undefined"):this.serialDisconnect().then(async()=>{await this.serialConnect()});break;case t.includes("'close' on 'serialport': a call to close() is already in progress."):break;case t.includes("failed to execute 'open' on 'serialport': a call to open() is already in progress."):break;case t.includes("the port is already closed."):break;case t.includes("the device has been lost"):this.dispatch("serial:lost",{}),u.$dispatchChange(this);break;case t.includes("navigator.serial is undefined"):this.dispatch("serial:unsupported",{});break;default:console.error(e);break}this.dispatch("serial:error",e)}async serialConnect(){try{this.dispatch("serial:connecting",{});const e=await y(this,g,se).call(this);if(e.length>0)await this.serialPortsSaved(e);else{const r=this.serialFilters;this.__internal__.serial.port=await navigator.serial.requestPort({filters:r})}const t=this.__internal__.serial.port;if(!t)throw new Error("No port selected by the user");await t.open(this.serialConfigPort);const n=this;t.onconnect=r=>{console.log(r),n.dispatch("serial:connected",r),u.$dispatchChange(this),n.__internal__.serial.queue.length>0&&n.dispatch("internal:queue",{})},t.ondisconnect=async()=>{await n.disconnect()},await H(this.__internal__.serial.delay_first_connection),this.__internal__.timeout.until_response=setTimeout(async()=>{await n.timeout(n.__internal__.serial.bytes_connection??[],"connection:start")},this.__internal__.time.response_connection),this.__internal__.serial.last_action="connect",await y(this,g,W).call(this,this.__internal__.serial.bytes_connection??[]),this.dispatch("serial:sent",{action:"connect",bytes:this.__internal__.serial.bytes_connection}),this.__internal__.auto_response&&y(this,g,E).call(this,this.__internal__.serial.auto_response),await y(this,g,ae).call(this)}catch(e){this.serialErrors(e)}}async serialForget(){return await y(this,g,le).call(this)}decToHex(e){return typeof e=="string"&&(e=parseInt(e,10)),e.toString(16)}hexToDec(e){return parseInt(e,16)}hexMaker(e="00",t=2){return e.toString().padStart(t,"0").toLowerCase()}add0x(e){const t=[];return e.forEach((n,r)=>{t[r]="0x"+n}),t}bytesToHex(e){return this.add0x(Array.from(e,t=>this.hexMaker(t)))}validateBytes(e){let t=new Uint8Array(0);if(e instanceof Uint8Array)t=e;else if(typeof e=="string")t=this.parseStringToTextEncoder(e);else if(Array.isArray(e)&&typeof e[0]=="string")t=this.stringArrayToUint8Array(e);else if(Array.isArray(e)&&typeof e[0]=="number")t=new Uint8Array(e);else throw new Error("Invalid data type");return t}async appendToQueue(e,t){const n=this.validateBytes(e);if(["connect","connection:start"].includes(t)){if(this.__internal__.serial.connected)return;await this.serialConnect();return}this.__internal__.serial.queue.push({bytes:n,action:t}),this.dispatch("internal:queue",{})}serialSetConnectionConstant(e=1){if(this.__internal__.bypassSerialBytesConnection)return this.__internal__.serial.bytes_connection;throw console.warn("wtf?",this.bypassSerialBytesConnection),new Error(`Method not implemented 'serialSetConnectionConstant' to listen on channel ${e}`)}serialMessage(e){throw console.log(e),this.dispatch("serial:message",{code:e}),new Error("Method not implemented 'serialMessage'")}serialCorruptMessage(e){throw console.log(e),this.dispatch("serial:corrupt-message",{code:e}),new Error("Method not implemented 'serialCorruptMessage'")}clearSerialQueue(){this.__internal__.serial.queue=[]}sumHex(e){let t=0;return e.forEach(n=>{t+=parseInt(n,16)}),t.toString(16)}toString(){return JSON.stringify({__class:this.typeDevice,device_number:this.deviceNumber,uuid:this.uuid,connected:this.isConnected,connection:this.__internal__.serial.bytes_connection})}softReload(){y(this,g,ue).call(this),this.dispatch("serial:soft-reload",{})}async sendConnect(){if(!this.__internal__.serial.bytes_connection)throw new Error("No connection bytes defined");await this.appendToQueue(this.__internal__.serial.bytes_connection,"connect")}async sendCustomCode({code:e=[]}={code:[]}){if(!e)throw new Error("No data to send");this.__internal__.bypassSerialBytesConnection&&(this.__internal__.serial.bytes_connection=this.validateBytes(e)),await this.appendToQueue(e,"custom")}stringToArrayHex(e){return Array.from(e).map(t=>t.charCodeAt(0).toString(16))}stringToArrayBuffer(e,t=`
`){return this.parseStringToTextEncoder(e,t).buffer}parseStringToTextEncoder(e="",t=`
`){const n=new TextEncoder;return e+=t,n.encode(e)}parseStringToBytes(e="",t=`
`){const n=this.parseStringToTextEncoder(e,t);return Array.from(n).map(r=>r.toString(16))}parseUint8ToHex(e){return Array.from(e).map(t=>t.toString(16))}parseHexToUint8(e){return new Uint8Array(e.map(t=>parseInt(t,16)))}stringArrayToUint8Array(e){const t=[];return typeof e=="string"?this.parseStringToTextEncoder(e).buffer:(e.forEach(n=>{const r=n.replace("0x","");t.push(parseInt(r,16))}),new Uint8Array(t))}parseUint8ArrayToString(e){let t=new Uint8Array(0);e instanceof Uint8Array?t=e:t=this.stringArrayToUint8Array(e),e=this.parseUint8ToHex(t);const n=e.map(r=>parseInt(r,16));return this.__internal__.serial.response.replacer?String.fromCharCode(...n).replace(this.__internal__.serial.response.replacer,""):String.fromCharCode(...n)}hexToAscii(e){const t=e.toString();let n="";for(let r=0;r<t.length;r+=2)n+=String.fromCharCode(parseInt(t.substring(r,2),16));return n}asciiToHex(e){const t=[];for(let n=0,r=e.length;n<r;n++){const _=Number(e.charCodeAt(n)).toString(16);t.push(_)}return t.join("")}$checkAndDispatchConnection(){return this.isConnected}}g=new WeakSet,T=function(l){return!!(l&&l.readable&&l.writable)},B=function(l=null){this.__internal__.serial.connected=!1,this.__internal__.aux_port_connector=0,this.dispatch("serial:disconnected",l),u.$dispatchChange(this)},W=async function(l){const e=this.__internal__.serial.port;if(!e||e&&(!e.readable||!e.writable))throw y(this,g,B).call(this,{error:"Port is closed, not readable or writable."}),new Error("The port is closed or is not readable/writable");const t=this.validateBytes(l);if(this.useRTSCTS&&await y(this,g,V).call(this,e,5e3),e.writable===null)return;const n=e.writable.getWriter();await n.write(t),n.releaseLock()},V=async function(l,e=5e3){const t=Date.now();for(;;){if(Date.now()-t>e)throw new Error("Timeout waiting for clearToSend signal");const{clearToSend:n}=await l.getSignals();if(n)return;await H(100)}},E=function(l=new Uint8Array([]),e=!1){if(l&&l.length>0){const t=this.__internal__.serial.connected;if(this.__internal__.serial.connected=y(this,g,T).call(this,this.__internal__.serial.port),u.$dispatchChange(this),!t&&this.__internal__.serial.connected&&this.dispatch("serial:connected"),this.__internal__.interval.reconnection&&(clearInterval(this.__internal__.interval.reconnection),this.__internal__.interval.reconnection=0),this.__internal__.timeout.until_response&&(clearTimeout(this.__internal__.timeout.until_response),this.__internal__.timeout.until_response=0),this.__internal__.serial.response.as==="hex")e?this.serialCorruptMessage(this.parseUint8ToHex(l)):this.serialMessage(this.parseUint8ToHex(l));else if(this.__internal__.serial.response.as==="uint8")e?this.serialCorruptMessage(l):this.serialMessage(l);else if(this.__internal__.serial.response.as==="string"){const n=this.parseUint8ArrayToString(l);if(this.__internal__.serial.response.limiter!==null){const r=n.split(this.__internal__.serial.response.limiter);for(const _ in r)r[_]&&(e?this.serialCorruptMessage(r[_]):this.serialMessage(r[_]))}else e?this.serialCorruptMessage(n):this.serialMessage(n)}else{const n=this.stringToArrayBuffer(this.parseUint8ArrayToString(l));e?this.serialCorruptMessage(n):this.serialMessage(n)}}this.__internal__.serial.queue.length!==0&&this.dispatch("internal:queue",{})},se=async function(){const l=this.serialFilters,e=await navigator.serial.getPorts({filters:l});return l.length===0?e:e.filter(t=>{const n=t.getInfo();return l.some(r=>n.usbProductId===r.usbProductId&&n.usbVendorId===r.usbVendorId)}).filter(t=>!y(this,g,T).call(this,t))},G=function(l){if(l){const e=this.__internal__.serial.response.buffer,t=new Uint8Array(e.length+l.byteLength);t.set(e,0),t.set(new Uint8Array(l),e.length),this.__internal__.serial.response.buffer=t}},z=async function(){this.__internal__.serial.time_until_send_bytes&&(clearTimeout(this.__internal__.serial.time_until_send_bytes),this.__internal__.serial.time_until_send_bytes=0),this.__internal__.serial.time_until_send_bytes=setTimeout(()=>{this.__internal__.serial.response.buffer&&y(this,g,E).call(this,this.__internal__.serial.response.buffer),this.__internal__.serial.response.buffer=new Uint8Array(0)},this.__internal__.serial.free_timeout_ms||50)},K=async function(){const l=this.__internal__.serial.response.length;let e=this.__internal__.serial.response.buffer;if(this.__internal__.serial.time_until_send_bytes&&(clearTimeout(this.__internal__.serial.time_until_send_bytes),this.__internal__.serial.time_until_send_bytes=0),!(l===null||!e||e.length===0)){for(;e.length>=l;){const t=e.slice(0,l);y(this,g,E).call(this,t),e=e.slice(l)}this.__internal__.serial.response.buffer=e,e.length>0&&(this.__internal__.serial.time_until_send_bytes=setTimeout(()=>{y(this,g,E).call(this,this.__internal__.serial.response.buffer,!0)},this.__internal__.serial.free_timeout_ms||50))}},X=async function(){const{limiter:l,prefixLimiter:e=!1,sufixLimiter:t=!0}=this.__internal__.serial.response;if(!l)throw new Error("No limiter defined for delimited serial response");const n=this.__internal__.serial.response.buffer;if(!l||!n||n.length===0)return;this.__internal__.serial.time_until_send_bytes&&(clearTimeout(this.__internal__.serial.time_until_send_bytes),this.__internal__.serial.time_until_send_bytes=0);let r=new TextDecoder().decode(n);const _=[];if(typeof l=="string"){let h;if(e&&t)h=new RegExp(`${l}([^${l}]+)${l}`,"g");else if(e)h=new RegExp(`${l}([^${l}]*)`,"g");else if(t)h=new RegExp(`([^${l}]+)${l}`,"g");else return;let d,w=0;for(;(d=h.exec(r))!==null;)_.push(new TextEncoder().encode(d[1])),w=h.lastIndex;r=r.slice(w)}else if(l instanceof RegExp){let h,d=0;if(e&&t){const w=new RegExp(`${l.source}(.*?)${l.source}`,"g");for(;(h=w.exec(r))!==null;)_.push(new TextEncoder().encode(h[1])),d=w.lastIndex}else if(t)for(;(h=l.exec(r))!==null;){const w=h.index,C=r.slice(d,w);_.push(new TextEncoder().encode(C)),d=l.lastIndex}else if(e){const w=r.split(l);w.shift();for(const C of w)_.push(new TextEncoder().encode(C));r=""}r=r.slice(d)}for(const h of _)y(this,g,E).call(this,h);const f=new TextEncoder().encode(r);this.__internal__.serial.response.buffer=f,f.length>0&&(this.__internal__.serial.time_until_send_bytes=setTimeout(()=>{y(this,g,E).call(this,this.__internal__.serial.response.buffer,!0),this.__internal__.serial.response.buffer=new Uint8Array(0)},this.__internal__.serial.free_timeout_ms??50))},ae=async function(){const l=this.__internal__.serial.port;if(!l||!l.readable)throw new Error("Port is not readable");const e=l.readable.getReader();this.__internal__.serial.reader=e;try{for(;this.__internal__.serial.keep_reading;){const{value:t,done:n}=await e.read();if(n)break;y(this,g,G).call(this,t),this.__internal__.serial.response.delimited?await y(this,g,X).call(this):this.__internal__.serial.response.length===null?await y(this,g,z).call(this):await y(this,g,K).call(this)}}catch(t){this.serialErrors(t)}finally{e.releaseLock(),this.__internal__.serial.keep_reading=!0,this.__internal__.serial.port&&await this.__internal__.serial.port.close()}},le=async function(){return typeof window>"u"?!1:"serial"in navigator&&"forget"in SerialPort.prototype&&this.__internal__.serial.port?(await this.__internal__.serial.port.forget(),!0):!1},oe=function(){["serial:connected","serial:connecting","serial:reconnect","serial:timeout","serial:disconnected","serial:sent","serial:soft-reload","serial:message","serial:corrupt-message","unknown","serial:need-permission","serial:lost","serial:unsupported","serial:error","debug"].forEach(l=>{this.serialRegisterAvailableListener(l)})},ce=function(){const l=this;this.on("internal:queue",async()=>{var e;await y(e=l,g,Z).call(e)}),y(this,g,Y).call(this)},Y=function(){const l=this;navigator.serial.addEventListener("connect",async()=>{l.isDisconnected&&await l.serialConnect().catch(()=>{})})},Z=async function(){if(!y(this,g,T).call(this,this.__internal__.serial.port)){y(this,g,B).call(this,{error:"Port is closed, not readable or writable."}),await this.serialConnect();return}if(this.__internal__.timeout.until_response||this.__internal__.serial.queue.length===0)return;const l=this.__internal__.serial.queue[0];let e=this.__internal__.time.response_general;if(l.action==="connect"&&(e=this.__internal__.time.response_connection),this.__internal__.timeout.until_response=setTimeout(async()=>{await this.timeout(l.bytes,l.action)},e),this.__internal__.serial.last_action=l.action??"unknown",await y(this,g,W).call(this,l.bytes),this.dispatch("serial:sent",{action:l.action,bytes:l.bytes}),this.__internal__.auto_response){let n=new Uint8Array(0);try{n=this.validateBytes(this.__internal__.serial.auto_response)}catch(r){this.serialErrors(r)}y(this,g,E).call(this,n)}const t=[...this.__internal__.serial.queue];this.__internal__.serial.queue=t.splice(1)},_e=function(l=1){this.__internal__.device_number=l,!this.__internal__.bypassSerialBytesConnection&&(this.__internal__.serial.bytes_connection=this.serialSetConnectionConstant(l))},ue=function(){this.__internal__.last_error={message:null,action:null,code:null,no_code:0}};u.instance||(u.instance=new u);const De={relay:[],locker:[],jofemar:[],boardroid:[],arduino:[],pinpad:[],pinpax:[]};u.devices={...u.devices,...De};u.addCustom=(l,e)=>{u.registerType(l),u.add(e)};u.getCustomByUuid=(l,e)=>u.get(l,e);u.getJofemarByUuid=l=>u.get("jofemar",l);u.getLockerByUuid=l=>u.get("locker",l);u.getRelayByUuid=l=>u.get("relay",l);u.getBoardroidByUuid=l=>u.get("boardroid",l);u.getArduinoByUuid=l=>u.get("arduino",l);u.getPinPadByUuid=l=>u.get("pinpad",l);u.getPinPaxByUuid=l=>u.get("pinpax",l);u.getJofemar=(l=1)=>u.getByNumber("jofemar",l);u.getBoardroid=(l=1)=>u.getByNumber("boardroid",l);u.getLocker=(l=1)=>u.getByNumber("locker",l);u.getRelay=(l=1)=>u.getByNumber("relay",l);u.getArduino=(l=1)=>u.getByNumber("arduino",l);u.getPinPad=(l=1)=>u.getByNumber("pinpad",l);u.getPinPax=(l=1)=>u.getByNumber("pinpax",l);class he extends xe{constructor(e){super(e),this.__internal__=structuredClone(this.__internal__),this.getResponseAsArrayHex(),this.__internal__.device.door_open=!1,this.__internal__.time.response_engines=2e3,this.__internal__.time.sense=100,this.__internal__.interval.waiting_sense=0,this.__internal__.dispense={must_response:!1,dispensing:!1,status:null,counter:0,limit_counter:20,custom_limit_counter:null,backup_dispense:{}}}get isDoorOpen(){return this.__internal__.device.door_open}get isDispensing(){return this.__internal__.interval.waiting_sense||this.__internal__.dispense.dispensing}async timeout(e,t){await super.timeout(e,t),t==="dispense"&&(this.__internal__.dispense.status="no-response")}async serialPortsSaved(e){const t=this.serialFilters;if(this.__internal__.aux_port_connector<e.length){const n=this.__internal__.aux_port_connector;this.__internal__.serial.port=e[n]}else this.__internal__.aux_port_connector=0,this.__internal__.serial.port=await navigator.serial.requestPort({filters:t});if(!this.__internal__.serial.port)throw new Error("Select another port please")}internalClearSensing(){this.__internal__.interval.waiting_sense&&clearInterval(this.__internal__.interval.waiting_sense),this.__internal__.interval.waiting_sense=0,this.__internal__.dispense.status=null,this.__internal__.dispense.counter=0,this.__internal__.dispense.dispensing=!1}internalDispensingProcess(){let e=this.__internal__.dispense.limit_counter;return this.__internal__.dispense.custom_limit_counter&&(e=this.__internal__.dispense.custom_limit_counter),e+=Math.ceil(e*.6),this.__internal__.dispense.counter>=e?(this.internalClearSensing(),this.__internal__.dispense.status=!1,this.__internal__.dispense.dispensing=!1,!1):(this.__internal__.dispense.counter=parseFloat((.1+this.__internal__.dispense.counter).toFixed(1)),this.__internal__.dispense.counter%1===0&&this.dispatch("dispensing",{status:this.__internal__.dispense.status,counter:this.__internal__.dispense.counter,limit:e}),null)}async internalDispenseStatus(){if(this.__internal__.dispense.must_response&&(await ee(this.__internal__.time.response_engines+10),this.__internal__.dispense.status==="no-response"))return this.internalClearSensing(),this.__internal__.dispense.status=!1,this.dispatch("not-dispensed",{reason:"no-response"}),{status:!1,error:"no-response"};this.__internal__.dispense.status=null,this.__internal__.dispense.dispensing=!0,this.dispatch("internal:dispense:running",{});const e=this;return new Promise(t=>{this.__internal__.interval.waiting_sense=setInterval(()=>{switch(e.__internal__.dispense.status){case null:e.internalDispensingProcess()===!1&&(e.internalClearSensing(),e.dispatch("not-dispensed",{reason:"timeout"}),t({status:!1,error:"timeout"}));break;case!0:e.internalClearSensing(),e.__internal__.dispense.status=!0,e.dispatch("dispensed",{}),t({status:!0,error:null});break;case!1:e.internalClearSensing(),e.__internal__.dispense.status=!1,e.dispatch("not-dispensed",{reason:"no-stock"}),t({status:!1,error:null});break;case"elevator-locked":e.internalClearSensing(),e.__internal__.dispense.status=!1,e.dispatch("not-dispensed",{reason:"elevator-locked"}),t({status:!1,error:"elevator-locked"});break;case"no-response":e.internalClearSensing(),e.__internal__.dispense.status=!1,e.dispatch("not-dispensed",{reason:"no-response"}),t({status:!1,error:"no-response"});break}},this.__internal__.time.sense)})}async internalDispense(e){if(this.isDispensing)throw new Error("Another dispensing process is running");if(!U.enable&&!this.__internal__.serial.connected&&(await this.serialConnect(),!this.__internal__.serial.connected))throw new Error("Serial device not connected");return this.__internal__.serial.queue.length===0?(await this.appendToQueue(e,"dispense"),await this.internalDispenseStatus()):new Promise(t=>{const n=setInterval(async()=>{if(this.__internal__.serial.queue.length>0)return;clearInterval(n),await this.appendToQueue(e,"dispense");const r=await this.internalDispenseStatus();t(r)},100)})}__emulate(e){if(typeof e.code!="object"){console.error("Invalid data to make an emulation");return}this.__internal__.serial.connected||(this.__internal__.serial.connected=!0,this.dispatch("serial:connected"),u.instance.dispatch("change"),this.__internal__.interval.reconnection&&(clearInterval(this.__internal__.interval.reconnection),this.__internal__.interval.reconnection=0)),this.__internal__.timeout.until_response&&(clearTimeout(this.__internal__.timeout.until_response),this.__internal__.timeout.until_response=0);const t=[];for(const n in e.code)t.push(e.code[n].toString().padStart(2,"0").toLowerCase());this.serialMessage(t)}set listenOnPort(e){this.listenOnChannel=e}get listenOnPort(){return this.__internal__.device.listen_on_port??1}}exports.Emulator=U;exports.Kernel=he;exports.getSeconds=ye;exports.h=u;exports.isEmpty=be;exports.supportCrypto=me;exports.supportGeolocation=ge;exports.supportWebSerial=pe;exports.wait=ee;
