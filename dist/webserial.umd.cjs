(function(s,i){typeof exports=="object"&&typeof module<"u"?i(exports):typeof define=="function"&&define.amd?define(["exports"],i):(s=typeof globalThis<"u"?globalThis:s||self,i(s.Webserial={}))})(this,function(s){"use strict";var J=Object.defineProperty;var x=s=>{throw TypeError(s)};var z=(s,i,_)=>i in s?J(s,i,{enumerable:!0,configurable:!0,writable:!0,value:_}):s[i]=_;var v=(s,i,_)=>z(s,typeof i!="symbol"?i+"":i,_),O=(s,i,_)=>i.has(s)||x("Cannot "+_);var f=(s,i,_)=>i.has(s)?x("Cannot add the same private member more than once"):i instanceof WeakSet?i.add(s):i.set(s,_);var d=(s,i,_)=>(O(s,i,"access private method"),_);var l,C,U,b,D,E,S,y,m,T;for(var i=[],_=0;_<256;++_)i.push((_+256).toString(16).slice(1));function P(r,n=0){return(i[r[n+0]]+i[r[n+1]]+i[r[n+2]]+i[r[n+3]]+"-"+i[r[n+4]]+i[r[n+5]]+"-"+i[r[n+6]]+i[r[n+7]]+"-"+i[r[n+8]]+i[r[n+9]]+"-"+i[r[n+10]]+i[r[n+11]]+i[r[n+12]]+i[r[n+13]]+i[r[n+14]]+i[r[n+15]]).toLowerCase()}var u,L=new Uint8Array(16);function I(){if(!u&&(u=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!u))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return u(L)}var A=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const w={randomUUID:A};function B(r,n,e){if(w.randomUUID&&!n&&!r)return w.randomUUID();r=r||{};var t=r.random||(r.rng||I)();return t[6]=t[6]&15|64,t[8]=t[8]&63|128,P(t)}class R extends EventTarget{dispatch(n,e=null){const t=new N(n,{detail:e});this.dispatchEvent(t)}on(n,e){this.addEventListener(n,e)}}class N extends CustomEvent{constructor(n,e){super(n,e)}}function q(r=100){return new Promise(n=>setTimeout(()=>n(),r))}function F(){return"serial"in navigator}class h extends R{constructor({filters:e=null,config_port:t=null,no_device:a=1}={}){super();f(this,l);v(this,"__internal__",{device_number:1,aux_port_connector:0,serial:{connected:!1,port:null,reader:null,input_done:null,output_done:null,input_stream:null,output_stream:null,keep_reading:!0,incoming:new Uint8Array(0),time_until_send_bytes:void 0,bytes_connection:null,navigator_not_supported:"_id_vl_not_support",filters:[],btn_connect_serial:null,config_port:{baudRate:9600,dataBits:8,stopBits:1,parity:"none",bufferSize:32768,flowControl:"none"}},device:{type:"unknown",id:B()},time:{response_connection:500},timeout:{until_response:0},interval:{reconnection:0},wait_until_last_command_returns:void 0,time_to_reconnect:7e3,time_response_general:2e3,queue_commands:[],last_error:{message:null,handler:null,code:null,no_code:0}});e&&(this.serialFilters=e),t&&(this.serialConfigPort=t),a&&(this.deviceNumber=a)}set serialFilters(e){this.__internal__.serial.filters=e}get serialFilters(){return this.__internal__.serial.filters}set serialConfigPort(e){this.__internal__.serial.config_port=e}get serialConfigPort(){return this.__internal__.serial.config_port}get isConnected(){return this.__internal__.serial.connected}set deviceNumber(e){this.__internal__.device_number=e}get deviceNumber(){return this.__internal__.device_number}get uuid(){return this.__internal__.device.id}get typeDevice(){return this.__internal__.device.type}async disconnect(e=null){this.isConnected&&this.dispatch("serial:disconnected",e),await this.serialDisconnect(),this.__internal__.serial.connected=!1,this.__internal__.aux_port_connector=0}async connect(){return new Promise((e,t)=>{F()||t("Web Serial not supported"),setTimeout(async()=>{await q(499),await this.serialConnect(),this.isConnected?e(`${this.typeDevice} device ${this.deviceNumber} connected`):t(`${this.typeDevice} device ${this.deviceNumber} not connected`)},1)})}async serialDisconnect(){try{const e=this.__internal__.serial.reader,t=this.__internal__.serial.output_stream;e&&(e.cancel().then(()=>{}).catch(c=>this.serialErrors(c)),await this.__internal__.serial.input_done,this.__internal__.serial.reader=null,this.__internal__.serial.input_done=null),t&&(await t.getWriter().close(),await this.__internal__.serial.output_done,this.__internal__.serial.output_stream=null,this.__internal__.serial.output_done=null),this.__internal__.serial.connected&&this.__internal__.serial.port.close(),this.__internal__.serial.connected=!1,this.__internal__.serial.port=null}catch(e){this.serialErrors(e)}}async serialPortsSaved(e){const t=this.serialFilters;if(this.__internal__.aux_port_connector<e.length){const a=this.__internal__.aux_port_connector;this.__internal__.serial.port=e[a]}else this.__internal__.aux_port_connector=0,this.__internal__.serial.port=await navigator.serial.requestPort({filters:t});if(!this.__internal__.serial.port)throw new Error("Select another port please")}serialErrors(e){const t=e.toString().toLowerCase();switch(!0){case t.includes("must be handling a user gesture to show a permission request"):case t.includes("the port is closed."):case t.includes("select another port please"):case t.includes("no port selected by the user"):case t.includes("this readable stream reader has been released and cannot be used to cancel its previous owner stream"):break;case t.includes("the port is already open."):this.serialDisconnect.then(async()=>{this.__internal__.aux_port_connector+=1,await this.serialConnect()});break;case t.includes("cannot read properties of undefined (reading 'writable')"):case t.includes("cannot read properties of null (reading 'writable')"):case t.includes("cannot read property 'writable' of null"):case t.includes("cannot read property 'writable' of undefined"):case t.includes("failed to open serial port"):this.serialDisconnect.then(async()=>{await this.serialConnect()});break;case t.includes("failed to execute 'open' on 'serialport': a call to open() is already in progress."):break;case t.includes("the device has been lost"):break;case t.includes("navigator.serial is undefined"):break}}async serialConnect(){try{const e=await d(this,l,D).call(this);if(e.length>0)await this.serialPortsSaved(e);else{const c=this.serialFilters;this.__internal__.serial.port=await navigator.serial.requestPort({filters:c})}const t=this.__internal__.serial.port;await t.open(this.serialConfigPort);const a=this;t.onconnect=c=>{a.dispatch("serial:connected",c.detail)},t.ondisconnect=async c=>{await a.disconnect(c.detail??null)},this.dispatch("serial:connecting",t.getInfo()),this.__internal__.timeout.until_response=setTimeout(async()=>{await a.timeout(a.__internal__.serial.bytes_connection,"connection:start")},this.__internal__.time.response_connection),await d(this,l,C).call(this,this.__internal__.serial.bytes_connection),this.typeDevice==="relay"&&d(this,l,b).call(this,["DD","DD"],null),await d(this,l,S).call(this)}catch(e){this.serialErrors(e)}}serialMessage(e){}serialCorruptMessage(e,t){}}l=new WeakSet,C=async function(e){const t=this.__internal__.serial.port;if(!t)throw new Error("The port is closed.");const a=new Uint8Array(e),c=t.writable.getWriter();await c.write(a),c.releaseLock()},U=function(e=[]){return e.map(t=>t.toString().toLowerCase())},b=function(e=[],t=null){e&&e.length>0?(this.__internal__.serial.connected=!0,this.__internal__.interval.reconnection&&(clearInterval(this.__internal__.interval.reconnection),this.__internal__.interval.reconnection=0),this.__internal__.timeout.until_response&&(clearTimeout(this.__internal__.timeout.until_response),this.__internal__.timeout.until_response=0),this.serialMessage(d(this,l,U).call(this,e))):this.serialCorruptMessage(e,t)},D=async function(){const e=this.serialFilters;return(await navigator.serial.getPorts({filters:e})).filter(a=>{const c=a.getInfo();return e.some(g=>c.usbProductId===g.usbProductId&&c.usbVendorId===g.usbVendorId)})},E=function(e){if(e!==void 0){const t=this.__internal__.serial.incoming;let a=new Uint8Array(t.length+e.byteLength);a.set(t,0),a.set(new Uint8Array(e),t.length),this.__internal__.serial.incoming=a}},S=async function(){const e=this.__internal__.serial.port;for(;e.readable&&this.__internal__.serial.keep_reading;){const t=e.readable.getReader();this.__internal__.serial.reader=t;try{let a=!0;for(;a;){const{value:c,done:g}=await t.read();if(g){t.releaseLock(),this.__internal__.serial.keep_reading=!1,a=!1;break}d(this,l,E).call(this,c),this.__internal__.serial.time_until_send_bytes&&(clearTimeout(this.__internal__.serial.time_until_send_bytes),this.__internal__.serial.time_until_send_bytes=0),this.__internal__.serial.time_until_send_bytes=setTimeout(()=>{let k=[];for(const $ in this.__internal__.serial.incoming)k.push(this.__internal__.serial.incoming[$].toString(16));this.__internal__.serial.incoming&&d(this,l,b).call(this,k),this.__internal__.serial.incoming=new Uint8Array(0)},400)}}catch(a){this.serialErrors(a)}finally{t.releaseLock()}}this.__internal__.serial.keep_reading=!0,await this.__internal__.serial.port.close()};const o=class o{static typeError(n){const e=new Error;throw e.message=`Type ${n} is not supported`,e.name="DeviceTypeError",e}static add(n){const e=n.typeDevice,t=n.uuid;if(typeof o.devices[e]>"u")return o.typeError(e);if(!o.devices[e][t])return o.devices[e][t]=n,o.devices[e].indexOf(n)}static get(n,e){return typeof o.devices[n]>"u"?o.typeError(n):o.devices[n][e]}static getJofemarByUuid(n){return o.get("jofemar",n)}static getLockerByUuid(n){return o.get("locker",n)}static getRelayByUuid(n){return o.get("relay",n)}static getBoardroidByUuid(n){return o.get("boardroid",n)}static getAll(n=null){return n===null?o.devices:typeof o.devices[n]>"u"?o.typeError(n):o.devices[n]}static getJofemar(n=1){return o.devices.jofemar.find(e=>e.deviceNumber===n)}static getBoardroid(n=1){return o.devices.boardroid.find(e=>e.deviceNumber===n)}static getLocker(n=1){return o.devices.locker.find(e=>e.deviceNumber===n)}static getRelay(n=1){return o.devices.relay.find(e=>e.deviceNumber===n)}};v(o,"devices",{relay:[],locker:[],jofemar:[],boardroid:[]});let p=o;class M extends h{constructor({filters:e=null,config_port:t=null,no_device:a=1}={}){super({filters:e,config_port:t,no_device:a});f(this,m);f(this,y,{activate:["A0","01","01","A2"],deactivate:["A0","01","00","A1"]});this.__internal__.device.type="relay",d(this,m,T).call(this)}serialMessage(e){const t={code:e,name:null,description:null,request:null,no_code:0};switch(e[1].toString()){case"dd":t.name="Connection with the serial device completed.",t.description="Your connection with the serial device was successfully completed.",t.request="connect",t.no_code=100;break;case"de":break;default:t.name="Unrecognized response",t.description="The response of application was received, but dont identify with any of current parameters",t.request="undefined",t.no_code=400;break}this.dispatch("serialMessage",t)}}y=new WeakMap,m=new WeakSet,T=function(){p.add(this)};class V extends h{constructor(){super()}}class W extends h{constructor(){super()}}class j extends h{constructor(){super()}}s.Boardroid=j,s.Devices=p,s.Jofemar=W,s.Locker=V,s.Relay=M,Object.defineProperty(s,Symbol.toStringTag,{value:"Module"})});
